diff -Naur --exclude .svn --exclude ps4 --exclude 'e1000-*' --exclude '*~' --exclude patch_e1000-7.2.7-ps4 e1000-7.2.7/src/e1000_main.c ps4/e1000_main.c
--- e1000-7.2.7/src/e1000_main.c	2006-07-25 23:39:31.000000000 +0200
+++ ps4/e1000_main.c	2006-08-22 12:59:55.000000000 +0200
@@ -81,7 +81,7 @@
 #else
 #define DRIVERNAPI "-NAPI"
 #endif
-#define DRV_VERSION "7.2.7"DRIVERNAPI
+#define DRV_VERSION "7.2.7"DRIVERNAPI" for ParaStation"
 char e1000_driver_version[] = DRV_VERSION;
 static char e1000_copyright[] = "Copyright (c) 1999-2006 Intel Corporation.";
 
@@ -404,6 +404,130 @@
 		E1000_WRITE_FLUSH(&adapter->hw);
 	}
 }
+
+/* ParaStation extension start */
+
+#ifdef CONFIG_E1000_NAPI
+#warning "CONFIG_E1000_NAPI might not work with ParaStation!!!"
+#endif
+
+#define MAX_e1000_irq_poll 16
+
+static struct {
+	struct net_device *netdev;
+	int irq;
+} e1000_irq_poll[MAX_e1000_irq_poll];
+
+static int e1000_irq_poll_last = 0;
+
+#ifdef CONFIG_SMP
+static spinlock_t e1000_intr_lock = SPIN_LOCK_UNLOCKED;
+#define E1000_INTR_TRYLOCK  spin_trylock(&e1000_intr_lock)
+#define E1000_INTR_UNLOCK   spin_unlock(&e1000_intr_lock)
+#define E1000_INTR_LOCK     spin_lock(&e1000_intr_lock)
+#else
+/* spin_trylock would return always 1 in UP kernels. Using just
+   volatile (not atomic_t) is save */
+static volatile int e1000_intr_lock = 0;
+#define E1000_INTR_TRYLOCK  (!e1000_intr_lock && ((e1000_intr_lock = 1)))
+#define E1000_INTR_UNLOCK   e1000_intr_lock = 0
+#define E1000_INTR_LOCK     e1000_intr_lock = 1 /* dont use this on SMP!!! */
+#endif
+
+static void
+e1000_add_poll(struct net_device *netdev, int irq)
+{
+	int i;
+	
+	if (e1000_irq_poll_last == MAX_e1000_irq_poll - 1)
+		return;
+	
+	for (i = 0; i < e1000_irq_poll_last; i++) {
+		if (e1000_irq_poll[i].netdev == netdev)
+			break;
+	}
+	e1000_irq_poll[i].netdev = netdev;
+	e1000_irq_poll[i].irq = irq;
+	
+	if (i == e1000_irq_poll_last) 
+		e1000_irq_poll_last++;
+}
+
+static void
+e1000_del_poll(struct net_device *netdev)
+{
+	int i;
+	for (i = 0; i < e1000_irq_poll_last; i++) {
+		if (e1000_irq_poll[i].netdev == netdev)
+			break;
+	}
+	
+	if ((i < e1000_irq_poll_last) &&
+	    (e1000_irq_poll[i].netdev == netdev)) {
+		e1000_irq_poll_last--;
+		e1000_irq_poll[i].netdev =
+			e1000_irq_poll[e1000_irq_poll_last].netdev;
+		e1000_irq_poll[i].irq =
+			e1000_irq_poll[e1000_irq_poll_last].irq;
+	}
+}
+
+static int
+e1000_intr2(struct e1000_adapter *adapter)
+{
+	int rc;
+	
+	e1000_clean_tx_irq(adapter, adapter->tx_ring);
+#ifdef CONFIG_E1000_NAPI
+	{
+		int work_done = 0;
+		rc = adapter->clean_rx(adapter, adapter->rx_ring, &work_done, 1);
+	}
+#else
+	rc = adapter->clean_rx(adapter, adapter->rx_ring);
+#endif
+	return rc;
+}
+
+#include "p4ether_pub.h"
+static char vcid_ps4poll[] __attribute__(( unused )) =
+"$Id: e1000_main.c 4272 2006-08-22 10:59:24Z hauke $";
+
+#ifdef CONFIG_E1000_NAPI
+p4ether_netif_rx_t *e1000_netif_rx = netif_receive_skb;
+#else
+p4ether_netif_rx_t *e1000_netif_rx = netif_rx;
+#endif
+
+void
+e1000_poll(void)
+{
+	int i;
+	if (!E1000_INTR_TRYLOCK) { /* Dont race with e1000_intr */
+		/* Busy lock */
+		return;
+	}
+	
+	for (i = 0; i < e1000_irq_poll_last; i++) {
+		struct net_device *netdev = e1000_irq_poll[i].netdev;
+//		e1000_intr(0, netdev, NULL);
+		if (e1000_intr2(netdev->priv))
+			break;
+	}
+	
+	E1000_INTR_UNLOCK;
+	
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+EXPORT_SYMBOL_NOVERS(e1000_poll);
+EXPORT_SYMBOL_NOVERS(e1000_netif_rx);
+#else
+EXPORT_SYMBOL(e1000_poll);
+EXPORT_SYMBOL(e1000_netif_rx);
+#endif
+
+/* ParaStation extension end */
 #ifdef NETIF_F_HW_VLAN_TX
 
 static void
@@ -548,6 +672,8 @@
 #endif
 	e1000_irq_enable(adapter);
 
+	e1000_add_poll(netdev, netdev->irq); /* ParaStation add polling. */
+	
 	return 0;
 }
 
@@ -603,6 +729,7 @@
 {
 	struct net_device *netdev = adapter->netdev;
 
+	e1000_del_poll(netdev); /* ParaStation del polling. */
 	e1000_irq_disable(adapter);
 
 	del_timer_sync(&adapter->tx_fifo_stall_timer);
@@ -2650,7 +2777,7 @@
 	uint8_t ipcss, ipcso, tucss, tucso, hdr_len;
 	int err;
 
-	if (skb_shinfo(skb)->tso_size) {
+	if (skb_shinfo(skb)->gso_size) {
 		if (skb_header_cloned(skb)) {
 			err = pskb_expand_head(skb, 0, 0, GFP_ATOMIC);
 			if (err)
@@ -2658,7 +2785,7 @@
 		}
 
 		hdr_len = ((skb->h.raw - skb->data) + (skb->h.th->doff << 2));
-		mss = skb_shinfo(skb)->tso_size;
+		mss = skb_shinfo(skb)->gso_size;
 		if (skb->protocol == htons(ETH_P_IP)) {
 			skb->nh.iph->tot_len = 0;
 			skb->nh.iph->check = 0;
@@ -2777,7 +2904,7 @@
 		 * tso gets written back prematurely before the data is fully
 		 * DMA'd to the controller */
 		if (!skb->data_len && tx_ring->last_tx_tso &&
-		    !skb_shinfo(skb)->tso_size) {
+		    !skb_shinfo(skb)->gso_size) {
 			tx_ring->last_tx_tso = 0;
 			size -= 4;
 		}
@@ -3025,7 +3152,7 @@
 	}
 
 #ifdef NETIF_F_TSO
-	mss = skb_shinfo(skb)->tso_size;
+	mss = skb_shinfo(skb)->gso_size;
 	/* The controller does a simple calculation to
 	 * make sure there is enough room in the FIFO before
 	 * initiating the DMA for each buffer.  The calc is:
@@ -3076,7 +3203,7 @@
 #ifdef NETIF_F_TSO
 	/* Controller Erratum workaround */
 	if (!skb->data_len && tx_ring->last_tx_tso &&
-	    !skb_shinfo(skb)->tso_size)
+	    !skb_shinfo(skb)->gso_size)
 		count++;
 #endif
 
@@ -3106,7 +3233,7 @@
 	    (adapter->hw.mac_type == e1000_82573))
 		e1000_transfer_dhcp_info(adapter, skb);
 
-#ifdef NETIF_F_LLTX
+#if defined(NETIF_F_LLTX) || 1 /* Busy lock (ParaStation poll) */
 	local_irq_save(flags);
 	if (!spin_trylock(&tx_ring->tx_lock)) {
 		/* Collision - tell upper layer to requeue */
@@ -3509,6 +3636,14 @@
 		return IRQ_NONE;  /* Not our interrupt */
 	}
 
+	/* ParaStation extension start */
+	if (!E1000_INTR_TRYLOCK) { /* Dont race with e1000_poll */
+//	    printk(KERN_INFO "Busy lock...\n");
+	    /* Busy lock */
+	    return IRQ_NONE;
+	}
+	/* ParaStation extension end */
+
 	if (unlikely(icr & (E1000_ICR_RXSEQ | E1000_ICR_LSC))) {
 		hw->get_link_status = 1;
 		/* 80003ES2LAN workaround--
@@ -3582,6 +3717,7 @@
 	adapter->icr_gpi += icr & 0x01;
 #endif
 
+	E1000_INTR_UNLOCK; /* <- ParaStation extension */
 	return IRQ_HANDLED;
 }
 
@@ -3683,11 +3819,22 @@
 #define TX_WAKE_THRESHOLD 32
 	if (unlikely(cleaned && netif_queue_stopped(netdev) &&
 	             netif_carrier_ok(netdev))) {
+#if 0		
 		spin_lock(&tx_ring->tx_lock);
 		if (netif_queue_stopped(netdev) &&
 		    (E1000_DESC_UNUSED(tx_ring) >= TX_WAKE_THRESHOLD))
 			netif_wake_queue(netdev);
 		spin_unlock(&tx_ring->tx_lock);
+#else
+                /* ParaStation: maybe race on tx_ring->tx_lock */
+		if (spin_trylock(&tx_ring->tx_lock)) {
+			if (netif_queue_stopped(netdev) &&
+			    (E1000_DESC_UNUSED(tx_ring) >= TX_WAKE_THRESHOLD))
+				netif_wake_queue(netdev);
+			spin_unlock(&tx_ring->tx_lock);
+		}
+#endif
+
 	}
 
 	if (adapter->detect_tx_hung) {
@@ -3857,12 +4004,24 @@
 			last_byte = *(skb->data + length - 1);
 			if (TBI_ACCEPT(&adapter->hw, status,
 			              rx_desc->errors, length, last_byte)) {
+#if 0
 				spin_lock_irqsave(&adapter->stats_lock, flags);
 				e1000_tbi_adjust_stats(&adapter->hw,
 				                       &adapter->stats,
 				                       length, skb->data);
 				spin_unlock_irqrestore(&adapter->stats_lock,
 				                       flags);
+#else
+				/* ParaStation: maybe race on adapter->stats_lock */
+				local_irq_save(flags);
+				if (spin_trylock(&adapter->stats_lock)) {
+					e1000_tbi_adjust_stats(&adapter->hw,
+							       &adapter->stats,
+							       length, skb->data);
+					spin_unlock_irqrestore(&adapter->stats_lock,
+							       flags);
+				}
+#endif
 				length--;
 			} else {
 				/* recycle */
@@ -3909,10 +4068,12 @@
 						 le16_to_cpu(rx_desc->special) &
 						 E1000_RXD_SPC_VLAN_MASK);
 		} else {
-			netif_receive_skb(skb);
+			// netif_receive_skb(skb);
+			e1000_netif_rx(skb); /* ParaStation Hook for fast-receive */
 		}
 #else
-		netif_receive_skb(skb);
+		// netif_receive_skb(skb);
+		e1000_netif_rx(skb); /* ParaStation Hook for fast-receive */
 #endif
 #else /* CONFIG_E1000_NAPI */
 #ifdef NETIF_F_HW_VLAN_TX
@@ -3922,10 +4083,13 @@
 					le16_to_cpu(rx_desc->special) &
 					E1000_RXD_SPC_VLAN_MASK);
 		} else {
-			netif_rx(skb);
+		        /* netif_rx(skb); */
+			e1000_netif_rx(skb); /* ParaStation Hook for fast-receive */
+
 		}
 #else
-		netif_rx(skb);
+		/* netif_rx(skb); */
+		e1000_netif_rx(skb); /* ParaStation Hook for fast-receive */
 #endif
 #endif /* CONFIG_E1000_NAPI */
 		netdev->last_rx = jiffies;
diff -Naur --exclude .svn --exclude ps4 --exclude 'e1000-*' --exclude '*~' --exclude patch_e1000-7.2.7-ps4 e1000-7.2.7/src/kcompat.h ps4/kcompat.h
--- e1000-7.2.7/src/kcompat.h	2006-07-25 23:39:31.000000000 +0200
+++ ps4/kcompat.h	2006-08-22 13:15:47.000000000 +0200
@@ -750,6 +750,10 @@
 
 #endif /* < 2.6.10 */
 
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,17) )
+#define gso_size tso_size
+#endif	
+
 #ifndef NET_IP_ALIGN
 #define NET_IP_ALIGN 2
 #endif
diff -Naur --exclude .svn --exclude ps4 --exclude 'e1000-*' --exclude '*~' --exclude patch_e1000-7.2.7-ps4 e1000-7.2.7/src/Makefile ps4/Makefile
--- e1000-7.2.7/src/Makefile	2006-07-25 23:39:31.000000000 +0200
+++ ps4/Makefile	2005-10-21 14:44:36.000000000 +0200
@@ -1,319 +1,11 @@
-################################################################################
-#
-# 
-# Copyright(c) 1999 - 2006 Intel Corporation. All rights reserved.
-# 
-# This program is free software; you can redistribute it and/or modify it 
-# under the terms of the GNU General Public License as published by the Free 
-# Software Foundation; either version 2 of the License, or (at your option) 
-# any later version.
-# 
-# This program is distributed in the hope that it will be useful, but WITHOUT 
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for 
-# more details.
-# 
-# You should have received a copy of the GNU General Public License along with
-# this program; if not, write to the Free Software Foundation, Inc., 59 
-# Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-# 
-# The full GNU General Public License is included in this distribution in the
-# file called LICENSE.
-# 
-# Contact Information:
-# Linux NICS <linux.nics@intel.com>
-# e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
-# Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
-#
-################################################################################
+# $Id: Makefile 3636 2005-05-10 16:31:31Z hauke $
 
-###########################################################################
-# Driver files
-
-# core driver files
-CFILES = e1000_main.c e1000_hw.c e1000_param.c \
-         e1000_ethtool.c kcompat.c
-HFILES = e1000.h e1000_hw.h e1000_osdep.h kcompat.h
-ifeq (,$(BUILD_KERNEL))
-BUILD_KERNEL=$(shell uname -r)
-endif
-
-###########################################################################
-# Environment tests
-
-# Kernel Search Path
-# All the places we look for kernel source
-KSP :=  /lib/modules/$(BUILD_KERNEL)/build \
-        /lib/modules/$(BUILD_KERNEL)/source \
-        /usr/src/linux-$(BUILD_KERNEL) \
-        /usr/src/linux-$($(BUILD_KERNEL) | sed 's/-.*//') \
-        /usr/src/kernel-headers-$(BUILD_KERNEL) \
-        /usr/src/kernel-source-$(BUILD_KERNEL) \
-        /usr/src/linux-$($(BUILD_KERNEL) | sed 's/\([0-9]*\.[0-9]*\)\..*/\1/') \
-        /usr/src/linux
-
-# prune the list down to only values that exist
-# and have an include/linux sub-directory
-test_dir = $(shell [ -e $(dir)/include/linux ] && echo $(dir))
-KSP := $(foreach dir, $(KSP), $(test_dir))
-
-# we will use this first valid entry in the search path
-ifeq (,$(KSRC))
-  KSRC := $(firstword $(KSP))
-endif
-
-ifeq (,$(KSRC))
-  $(error Linux kernel source not found)
-else
-ifeq (/lib/modules/$(shell uname -r)/source, $(KSRC))
-  KOBJ :=  /lib/modules/$(shell uname -r)/build
-else
-  KOBJ :=  $(KSRC)
-endif
-endif
-
-# check for version.h and autoconf.h for running kernel in /boot (SUSE)
-ifneq (,$(wildcard /boot/vmlinuz.version.h))
-  VERSION_FILE := /boot/vmlinuz.version.h
-  CONFIG_FILE  := /boot/vmlinuz.autoconf.h
-  KVER := $(shell $(CC) $(CFLAGS) -E -dM $(VERSION_FILE) | \
-          grep UTS_RELEASE | awk '{ print $$3 }' | sed 's/\"//g')
-  ifeq ($(KVER),$(shell uname -r))
-    # set up include path to override headers from kernel source
-    x:=$(shell rm -rf include)
-    x:=$(shell mkdir -p include/linux)
-    x:=$(shell cp /boot/vmlinuz.version.h include/linux/version.h)
-    x:=$(shell cp /boot/vmlinuz.autoconf.h include/linux/autoconf.h)
-    CFLAGS += -I./include
-  else
-    VERSION_FILE := $(KOBJ)/include/linux/version.h
-    CONFIG_FILE  := $(KSRC)/include/linux/autoconf.h
-  endif
-else
-  VERSION_FILE := $(KOBJ)/include/linux/version.h
-  CONFIG_FILE  := $(KSRC)/include/linux/autoconf.h
-endif
-
-ifeq (,$(wildcard $(VERSION_FILE)))
-  $(error Linux kernel source not configured - missing version.h)
-endif
-
-ifeq (,$(wildcard $(CONFIG_FILE)))
-  $(error Linux kernel source not configured - missing autoconf.h)
-endif
-
-# pick a compiler
-ifneq (,$(findstring egcs-2.91.66, $(shell cat /proc/version)))
-  CC := kgcc gcc cc
-else
-  CC := gcc cc
-endif
-test_cc = $(shell $(cc) --version > /dev/null 2>&1 && echo $(cc))
-CC := $(foreach cc, $(CC), $(test_cc))
-CC := $(firstword $(CC))
-ifeq (,$(CC))
-  $(error Compiler not found)
-endif
-
-# we need to know what platform the driver is being built on
-# some additional features are only built on Intel platforms
-ARCH := $(shell uname -m | sed 's/i.86/i386/')
-ifeq ($(ARCH),alpha)
-  CFLAGS += -ffixed-8 -mno-fp-regs
-endif
-ifeq ($(ARCH),x86_64)
-  CFLAGS += -mcmodel=kernel -mno-red-zone
-endif
-ifeq ($(ARCH),ppc)
-  CFLAGS += -msoft-float
-endif
-ifeq ($(ARCH),ppc64)
-  CFLAGS += -m64 -msoft-float
-  LDFLAGS += -melf64ppc
-endif
-
-# standard flags for module builds
-CFLAGS += -DLINUX -D__KERNEL__ -DMODULE -O2 -pipe -Wall
-CFLAGS += -I$(KSRC)/include -I.
-CFLAGS += $(shell [ -f $(KSRC)/include/linux/modversions.h ] && \
-            echo "-DMODVERSIONS -DEXPORT_SYMTAB \
-                  -include $(KSRC)/include/linux/modversions.h")
-
-CFLAGS += $(CFLAGS_EXTRA)
-#ifeq (,$(shell echo $(CFLAGS_EXTRA) | grep NAPI))
-#CFLAGS += -DE1000_NO_NAPI
-#CFLAGS_EXTRA += -DE1000_NO_NAPI
-#endif
-
-RHC := $(KSRC)/include/linux/rhconfig.h
-ifneq (,$(wildcard $(RHC)))
-  # 7.3 typo in rhconfig.h
-  ifneq (,$(shell $(CC) $(CFLAGS) -E -dM $(RHC) | grep __module__bigmem))
-	CFLAGS += -D__module_bigmem
-  endif
-endif
-
-# get the kernel version - we use this to find the correct install path
-KVER := $(shell $(CC) $(CFLAGS) -E -dM $(VERSION_FILE) | grep UTS_RELEASE | \
-        awk '{ print $$3 }' | sed 's/\"//g')
-
-KKVER := $(shell echo $(KVER) | \
-         awk '{ if ($$0 ~ /2\.[4-9]\./) print "1"; else print "0"}')
-ifeq ($(KKVER), 0)
-  $(error *** Aborting the build. \
-          *** This driver is not supported on kernel versions older than 2.4.0)
-endif
-
-# set the install path
-INSTDIR := /lib/modules/$(KVER)/kernel/drivers/net/e1000
-
-# look for SMP in config.h
-SMP := $(shell $(CC) $(CFLAGS) -E -dM $(CONFIG_FILE) | \
-         grep -w CONFIG_SMP | awk '{ print $$3 }')
-ifneq ($(SMP),1)
-  SMP := 0
-endif
-
-ifneq ($(SMP),$(shell uname -a | grep SMP > /dev/null 2>&1 && echo 1 || echo 0))
-  $(warning ***)
-  ifeq ($(SMP),1)
-    $(warning *** Warning: kernel source configuration (SMP))
-    $(warning *** does not match running kernel (UP))
-  else
-    $(warning *** Warning: kernel source configuration (UP))
-    $(warning *** does not match running kernel (SMP))
-  endif
-  $(warning *** Continuing with build,)
-  $(warning *** resulting driver may not be what you want)
-  $(warning ***)
-endif
-
-ifeq ($(SMP),1)
-  CFLAGS += -D__SMP__
-endif
-
-###########################################################################
-# 2.4.x & 2.6.x Specific rules
-
-K_VERSION:=$(shell uname -r | cut -c1-3 | sed 's/2\.[56]/2\.6/')
-
-ifeq ($(K_VERSION), 2.6)
-
-# Makefile for 2.6.x kernel
-TARGET = e1000.ko
-
-# man page
-MANSECTION = 7
-MANFILE = $(TARGET:.ko=.$(MANSECTION))
-
-ifneq ($(PATCHLEVEL),)
-EXTRA_CFLAGS += $(CFLAGS_EXTRA)
 obj-m += e1000.o
-e1000-objs := $(CFILES:.c=.o)
-else
-default:
-ifeq ($(KOBJ),$(KSRC))
-	make -C $(KSRC) SUBDIRS=$(shell pwd) modules
-else
-	make -C $(KSRC) O=$(KOBJ) SUBDIRS=$(shell pwd) modules
-endif
-endif
-
-else # ifeq ($(K_VERSION),2.6)
-
-# Makefile for 2.4.x kernel
-TARGET = e1000.o
-
-# man page
-MANSECTION = 7
-MANFILE = $(TARGET:.o=.$(MANSECTION))
-
-# Get rid of compile warnings in kernel header files from SuSE
-ifneq (,$(wildcard /etc/SuSE-release))
-  CFLAGS += -Wno-sign-compare -fno-strict-aliasing
-endif
-
-# Get rid of compile warnings in kernel header files from fedora
-ifneq (,$(wildcard /etc/fedora-release))
-  CFLAGS += -fno-strict-aliasing
-endif
-
-.SILENT: $(TARGET)
-$(TARGET): $(filter-out $(TARGET), $(CFILES:.c=.o))
-	$(LD) $(LDFLAGS) -r $^ -o $@
-	echo; echo
-	echo "**************************************************"
-	echo "** $(TARGET) built for $(KVER)"
-	echo -n "** SMP               "
-	if [ "$(SMP)" = "1" ]; \
-		then echo "Enabled"; else echo "Disabled"; fi
-	echo "**************************************************"
-	echo
-
-$(CFILES:.c=.o): $(HFILES) Makefile
-default:
-	make
-
-endif # ifeq ($(K_VERSION),2.6)
-
-ifeq (,$(MANDIR))
-  # find the best place to install the man page
-  MANPATH := $(shell (manpath 2>/dev/null || echo $MANPATH) | sed 's/:/ /g')
-  ifneq (,$(MANPATH))
-    # test based on inclusion in MANPATH
-    test_dir = $(findstring $(dir), $(MANPATH))
-  else
-    # no MANPATH, test based on directory existence
-    test_dir = $(shell [ -e $(dir) ] && echo $(dir))
-  endif
-  # our preferred install path
-  # should /usr/local/man be in here ?
-  MANDIR := /usr/share/man /usr/man
-  MANDIR := $(foreach dir, $(MANDIR), $(test_dir))
-  MANDIR := $(firstword $(MANDIR))
-endif
-ifeq (,$(MANDIR))
-  # fallback to /usr/man
-  MANDIR := /usr/man
-endif
-
-# depmod version for rpm builds
-DEPVER := $(shell /sbin/depmod -V 2>/dev/null | \
-          awk 'BEGIN {FS="."} NR==1 {print $$2}')
-
-###########################################################################
-# Build rules
-
-$(MANFILE).gz: ../$(MANFILE)
-	gzip -c $< > $@
-
-install: default $(MANFILE).gz
-	# remove all old versions of the driver
-	find $(INSTALL_MOD_PATH)/lib/modules/$(KVER) -name $(TARGET) -exec rm -f {} \; || true
-	find $(INSTALL_MOD_PATH)/lib/modules/$(KVER) -name $(TARGET).gz -exec rm -f {} \; || true
-	install -D -m 644 $(TARGET) $(INSTALL_MOD_PATH)$(INSTDIR)/$(TARGET)
-ifeq (,$(INSTALL_MOD_PATH))
-	/sbin/depmod -a || true
-else
-  ifeq ($(DEPVER),1 )
-	/sbin/depmod -r $(INSTALL_MOD_PATH) -a || true
-  else
-	/sbin/depmod -b $(INSTALL_MOD_PATH) -a -n > /dev/null || true
-  endif
-endif
-	install -D -m 644 $(MANFILE).gz $(INSTALL_MOD_PATH)$(MANDIR)/man$(MANSECTION)/$(MANFILE).gz
-	man -c -P'cat > /dev/null' $(MANFILE:.$(MANSECTION)=) || true
-
-uninstall:
-	if [ -e $(INSTDIR)/$(TARGET) ] ; then \
-	    rm -f $(INSTDIR)/$(TARGET) ; \
-	fi
-	/sbin/depmod -a
-	if [ -e $(MANDIR)/man$(MANSECTION)/$(MANFILE).gz ] ; then \
-		rm -f $(MANDIR)/man$(MANSECTION)/$(MANFILE).gz ; \
-	fi
 
-.PHONY: clean install
+e1000-objs	:= e1000_main.o e1000_hw.o e1000_ethtool.o
+e1000-objs	+= e1000_param.o
+# e1000_proc.o
+e1000-objs	+= kcompat.o
+EXTRA_CFLAGS += -I$(P4_TOP_SRCDIR)/include -DE1000_NO_NAPI
 
-clean:
-	rm -rf $(TARGET) $(TARGET:.ko=.o) $(TARGET:.ko=.mod.c) $(TARGET:.ko=.mod.o) $(CFILES:.c=.o) $(MANFILE).gz .*cmd .tmp_versions
+-include ../Makefile.compat
